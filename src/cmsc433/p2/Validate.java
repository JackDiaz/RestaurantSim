package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Validates a simulation
 */
public class Validate {
	//Jack Diaz 111499298
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @return whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			// make sure it starts with the sim starting event
			check(events.get(events.size()-1).event == 
					SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");
			// make sure it ends with the sim ending event

			SimulationEvent first = events.get(0);
			// gather data about this sim

			int eatCount = 0, cookCount = 0, 
					// counts to make sure there are proper number
					eatersGone = 0, 
					// to make sure all eaters are gone before cooks leave
					eatersSeated = 0,
					// to make sure there is only one eater per table
					numEaters = first.simParams[0], numCooks = first.simParams[1], 
					tables = first.simParams[2], capacity = first.simParams[3];
			// from the sim, used to compare

			List<Integer> completedOrders = new ArrayList<Integer>();
			// list of completed orders
			List<Integer> receivedOrders = new ArrayList<Integer>();
			// list of orders received by eaters
			List<Eater> eatersEaten = new ArrayList<Eater>();
			// list of eaters who have eaten and left
			List<Eater> eatersOrdered = new ArrayList<Eater>();
			// list of eaters who have ordered
			List<Integer> ordersPlaced = new ArrayList<Integer>();
			// list of orders that have been placed

			Map<String, Integer> machCap = new HashMap<String, Integer>();
			machCap.put("Grill", 0);
			machCap.put("Frier", 0);
			machCap.put("Soda Fountain", 0);
			// make sure no machine is above capacity

			Map<String, String> machines = new HashMap<String, String>();
			machines.put("Grill","burger");
			machines.put("Frier","fries");
			machines.put("Soda Fountain","coke");
			// mapping machine names to food names

			Set<Eater> eaters = new HashSet<Eater>();
			// set of eaters
			Set<Cook> cooks = new HashSet<Cook>();
			// set of cooks
			Set<Eater> eatersGoneSet = new HashSet<Eater>();
			// set of eaters who have left
			Map<Integer, List<Food>> ordersStarted = new HashMap<Integer, List<Food>>();
			// set of tuples which are (orderNum, food)
			// these represent foods that have been started for a specific order

			Map<Eater, String> eaterState = new HashMap<Eater, String>();
			// enforced order below for each eater
			// Eater: starts > enters > place > receive > leave
			Map<Cook, String> cookState = new HashMap<Cook, String>();
			// enforces order below for each cook
			// Cook: start > receive > startfood > finishfood > completeorder > end
			Map<Cook, Set<String>> cooked = new HashMap<Cook, Set<String>>();
			// names of foods that a certain cook has cooked 
			// used when making sure an order is completed

			Map<Integer, String> orderState = new HashMap<Integer, String>();
			// enforces order below for each order
			// eater starts > eater enters > places order > cook receives > startfood 
			// > machcook > machdone > finishfood > complete order > eater receive > eater leave

			Map<String, String> machState = new HashMap<String, String>();
			// enforces order below for each machine
			// machine: start > cook > done > end
			
			int cooksGone = 0;
			Map<String, Integer> numFoodSub = new HashMap<String, Integer>();
			numFoodSub.put("burger", 0);
			numFoodSub.put("fries", 0);
			numFoodSub.put("coke", 0);
			
			Map<String, Integer> numFoodDone = new HashMap<String, Integer>();
			numFoodDone.put("burger", 0);
			numFoodDone.put("fries", 0);
			numFoodDone.put("coke", 0);
			





			for(SimulationEvent e : events){
				// Eater: starts > enters > place > receive > leave
				if(e.event == SimulationEvent.EventType.EaterStarting){
					eatCount++;
					// new eater

					check(!eaters.contains(e.eater), e.eater.toString()+" started twice");
					eaters.add(e.eater);
					// make sure he hasn't already started

					check(eaterState.get(e.eater) == null, e.eater.toString()+" did something before starting");
					// make sure his state is null
					// otherwise we know something has already changed his state
					eaterState.put(e.eater, "started");
					// change state to started
				}
				if(e.event == SimulationEvent.EventType.EaterEnteredRestaurant){
					eatersSeated++;
					check(eatersSeated <= tables, "More Eaters than tables");
					// takes a seat, checks if this exceeds restaurant's capacity

					check(eaterState.get(e.eater) == "started", e.eater.toString()+" entered before starting");
					// make sure he has started and has not done anything since
					eaterState.put(e.eater, "entered");
					// change state to entered
				}
				if(e.event == SimulationEvent.EventType.EaterPlacedOrder){
					check(!eatersOrdered.contains(e.eater), e.eater.toString()+" ordered more than once");
					eatersOrdered.add(e.eater);
					//make sure he hasn't ordered already

					check(!ordersPlaced.contains(e.orderNumber), "Order #"+e.orderNumber+"was placed twice");
					ordersPlaced.add(e.orderNumber);
					// check that this order hasn't already been placed
					

					check(eaterState.get(e.eater) == "entered", e.eater.toString()+" placed order before entering");
					eaterState.put(e.eater, "placed");
					// 

					check(orderState.get(e.orderNumber) == null, 
							e.eater.toString()+" placed order #"+e.orderNumber+" more than once");
					orderState.put(e.orderNumber, "placed");
				}
				if(e.event == SimulationEvent.EventType.EaterReceivedOrder){
					check(completedOrders.contains(e.orderNumber), e.eater.toString()+" received incomplete order #"+e.orderNumber);
					check(!receivedOrders.contains(e.orderNumber), e.eater.toString()+" received order #"+e.orderNumber+" twice");
					receivedOrders.add(e.orderNumber);

					eatersEaten.add(e.eater);

					check(eaterState.get(e.eater) == "placed", e.eater.toString()+" received order before placing an order");
					eaterState.put(e.eater, "received");

					check(orderState.get(e.orderNumber) == "complete", 
							e.eater.toString()+" received order #"+e.orderNumber+" before it was complete");
					orderState.put(e.orderNumber, "eaterRec");
				}
				if(e.event == SimulationEvent.EventType.EaterLeavingRestaurant){
					check(eatersEaten.contains(e.eater), e.eater.toString()+" left without food");

					eatersGone++;
					eatersSeated--;

					check(!eatersGoneSet.contains(e.eater), e.eater.toString()+" left twice");
					eatersGoneSet.add(e.eater);

					check(eaterState.get(e.eater) == "received", e.eater.toString()+" left before receiving an order");
					eaterState.put(e.eater, "gone");
				}

				// Cook: start > receive > startfood > finishfood > completeorder > end
				if(e.event == SimulationEvent.EventType.CookStarting){
					cookCount++;

					check(!cooks.contains(e.cook), e.cook.toString()+" started twice");
					cooks.add(e.cook);

					check(cookState.get(e.cook) == null, e.cook.toString()+" did something before starting");
					cookState.put(e.cook, "started");

					cooked.put(e.cook, new HashSet<String>());
				}
				if(e.event == SimulationEvent.EventType.CookReceivedOrder){
					check(ordersPlaced.contains(e.orderNumber), e.cook.toString()+" received order #"+e.orderNumber+" before it was placed");

					check(cookState.get(e.cook) == "started", e.cook.toString()+" started cooking before receiving an order");
					cookState.put(e.cook, "received");

					check(orderState.get(e.orderNumber) == "placed", 
							e.cook.toString()+" received order #"+e.orderNumber+" before it was placed");
					orderState.put(e.orderNumber, "cookRec");
				}
				if(e.event == SimulationEvent.EventType.CookStartedFood){
					check(ordersPlaced.contains(e.orderNumber), e.cook.toString()+" started cooking before order was placed");

					if(ordersStarted.get(e.orderNumber) == null){
						ordersStarted.put(e.orderNumber, new ArrayList<Food>());
					}
					check(!ordersStarted.get(e.orderNumber).contains(e.food), 
							e.cook.toString()+" started "+e.food.name+" for order #"+e.orderNumber+" twice");
					ordersStarted.get(e.orderNumber).add(e.food);

					check((orderState.get(e.orderNumber) == "cookRec"
							|| orderState.get(e.orderNumber) == "cooking"), 
							e.cook.toString()+" started cooking order #"+e.orderNumber+" before receiving it");
					orderState.put(e.orderNumber, "cooking");
					
					numFoodSub.put(e.food.name, numFoodSub.get(e.food.name)+1);
				}
				if(e.event == SimulationEvent.EventType.CookFinishedFood){
					check(ordersPlaced.contains(e.orderNumber), e.cook.toString()+" finished cooking before order was placed");

					check(!cooked.get(e.cook).contains(e.food), e.cook.toString()+" finished "+e.food.name+" for order #"+e.orderNumber+" twice");
					cooked.get(e.cook).add(e.food.name);

					check(orderState.get(e.orderNumber) == "cooking", 
							e.cook.toString()+" finished cooking order #"+e.orderNumber+" before starting it");
				}
				if(e.event == SimulationEvent.EventType.CookCompletedOrder){
					check(ordersPlaced.contains(e.orderNumber), e.cook.toString()+" completed order before order was placed");

					check(!completedOrders.contains(e.orderNumber), "Order #"+e.orderNumber+" completed twice");
					completedOrders.add(e.orderNumber);

					check(cookState.get(e.cook) == "received", e.cook.toString()+" completed order before receiving an order");
					cookState.put(e.cook, "started");

					Set<String> complete = cooked.get(e.cook);
					check(complete.contains("burger"), e.cook.toString()+" completed order before burger finished");
					check(complete.contains("fries"), e.cook.toString()+" completed order before fries finished");
					check(complete.contains("coke"), e.cook.toString()+" completed order before coke finished");
					cooked.put(e.cook, new HashSet<String>());

					check(orderState.get(e.orderNumber) == "cooking", 
							e.cook.toString()+" completed order #"+e.orderNumber+" before cooking it");
					orderState.put(e.orderNumber, "complete");
				}
				if(e.event == SimulationEvent.EventType.CookEnding){
					check(eatersGone == numEaters, e.cook.toString()+" left before all the eaters were gone");

					check(cookState.get(e.cook) != null, e.cook.toString()+" ended before starting");
					check(cookState.get(e.cook) == "started", e.cook.toString()+" ended before completing an order");
					cookState.put(e.cook, "ended");
					
					cooksGone++;
				}

				if(e.event == SimulationEvent.EventType.MachineStarting){
					check(machState.get(e.machine.name) == null, e.machine.toString()+" did something before turning on");
					machState.put(e.machine.name, "ready");
				}
				if(e.event == SimulationEvent.EventType.MachineStartingFood){
					String machName = e.machine.name;
					int num = machCap.get(machName)+1;
					machCap.put(machName, num);

					check(num <= capacity, machName+" is above capacity");

					check(machines.get(e.machine.name) == e.food.name, 
							e.machine.name+" got "+e.food.name);

					check((machState.get(e.machine.name) == "ready"
							|| machState.get(e.machine.name) == "startFood")
							, e.machine.toString()+" started cooking before turning on");
					machState.put(e.machine.name, "startFood");
					numFoodDone.put(e.food.name, numFoodDone.get(e.food.name)+1);
					check(numFoodDone.get(e.food.name).equals(numFoodSub.get(e.food.name)), "Imbalance between food submitted and food cooked");
				}
				if(e.event == SimulationEvent.EventType.MachineDoneFood){
					String machName = e.machine.name;
					int num = machCap.get(machName)-1;
					machCap.put(machName, num);

					check(num >= 0, machName+" has fewer than 0 items");

					check(machines.get(e.machine.name) == e.food.name, 
							e.machine.name+" got "+e.food.name);

					check((machState.get(e.machine.name) == "ready"
							|| machState.get(e.machine.name) == "startFood"), e.machine.toString()+" finished cooking before starting food");
					machState.put(e.machine.name, "ready");
				}
				if(e.event == SimulationEvent.EventType.MachineEnding){
					check(machState.get(e.machine.name) == "ready", e.machine.toString()+" ended before finishing food");
					machState.put(e.machine.name, "off");
				}
			}

			check(eatCount == numEaters, "Wrong number of eaters");
			check(cookCount == numCooks, "Wrong number of cooks");
			check(receivedOrders.containsAll(completedOrders), "Eater did not receive order");
			check(completedOrders.containsAll(receivedOrders), "Eater received an order that wasn't completed");
			check(eatersOrdered.size() == numEaters, "Imbalance between number of eaters and number of placed orders");
			check(completedOrders.size() == numEaters, "Imbalance between number of eaters and number of completed orders");
			check(receivedOrders.size() == numEaters, "Imbalance between number of eaters and number of received orders");
			check(eatersEaten.size() == numEaters, "Imbalance between number of eaters and number of people who ate");
			check(eatersGone == numEaters, "Imbalance between number of eaters and number of eaters who left");
			check(ordersPlaced.size() == numEaters, "Imbalance between number of eaters and number of orders placed");
			check(eaters.size() == numEaters, "Imbalance between number of eaters and number of eaters started");
			check(cooks.size() == numCooks, "Imbalance between number of cooks and number of cooks started");
			check(eatersGoneSet.size() == numEaters, "Imbalance between number of eaters and number of people who left");
			check(ordersStarted.size() == numEaters, "Imbalance between number of eaters and number orders started");
			check(cooksGone == numCooks, "Imbalance between number of cooks and number cooks who left");
/*
			Set<String> eaterNames = new HashSet<String>();
			for(int i = 0; i < numEaters; i++){
				eaterNames.add("Eater "+i);
			}

			for(Eater e : eaters){
				check(eaterNames.contains(e.toString()), "Invalid eater name: "+e.toString());
			}

			Set<String> cookNames = new HashSet<String>();
			for(int i = 0; i < numCooks; i++){
				cookNames.add("Cook "+i);
			}

			for(Cook c : cooks){
				check(cookNames.contains(c.toString()), "Invalid cook name: "+c.toString());
			}
*/
			// removed the name check because the submit server didn't like it

			/* Write validation code for (at least) the following :
				#Should not have more eaters than specified
				#Should not have more cooks than specified
				#The restaurant capacity should not be exceeded
				#The capacity of each machine should not be exceeded
				#Eater should not receive order until cook completes it
				#Eater should not leave restaurant until order is received
				#Eater should not place more than one order
				#Cook should not work on order before it is placed
				#Cooks don't leave before all eaters have left
				#machines get right food
				#Each eater's order must be given a unique order number
				#All eater names should be of the form "Eater "+num where num is between 0 and the number of eaters minus one
				#Eater: starts > enters > place > receive > leave
				#All cook names should be of the form "Cook "+num where num is between 0 and the number of cooks minus one.
				#Cook: start > receive > startfood > finishfood > completeorder > end
				#eater enters > places order > cook receives > startfood 
				#> machcook > machdone > finishfood > complete order > eater receive > eater leave
				#cook should not start a new order until last order is finished
				#machine: start > cook > done > end


				NOTE: These are only SOME of the
				requirements for a correct
				simulation. You should think carefully
				about whether there are additional
				constraints, according to the
				specification, that should be checked
				for. The validation code used on the
				grading server may check things
				according to more stringent
				requirements. 
			 */

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
